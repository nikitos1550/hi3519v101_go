#include "../hisi_external.h"
#include "hi3516av200_mpp.h"

#include <string.h>

int hisi_encoders_max_num(unsigned int * num) {
    *num = VENC_MAX_CHN_NUM;
    return ERR_NONE;
}

/*
int hisi_encoder_fetch  (unsigned int id,
                        struct encoder_static_params * sparams) {

}

int hisi_encoder_delete (unsigned int id) {


}
*/














///////////////////////////////////////////////////////////////////

int hisi_encoder_info   (unsigned int id,
                        struct encoder_static_params * sparams,
                        struct encoder_dynamic_params * dparams) {
    int error_code = 0;

    if (id < 0 &&
        id >= VENC_MAX_CHN_NUM) return ERR_OBJECT_NOT_FOUNT;

    VENC_CHN_ATTR_S stChnAttr;

    error_code = HI_MPI_VENC_GetChnAttr(id, &stChnAttr);
    if (error_code != HI_SUCCESS) {
        if (error_code == HI_ERR_VENC_UNEXIST) {
            return ERR_OBJECT_NOT_FOUNT;
        }
        return ERR_MPP;
    }

    //TODO
    //error_code = hi3516av200_get_params(&stChnAttr, &sparams, &dparams);

    MPP_CHN_S stSrcChn;
    MPP_CHN_S stDestChn;

    stDestChn.enModId  = HI_ID_VENC;
    stDestChn.s32DevId = 0;
    stDestChn.s32ChnId = id;

    error_code =  HI_MPI_SYS_GetBindbyDest(&stDestChn, &stSrcChn);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_delete: hisi_encoder_info %d failed %#x\n", id, error_code);
        return ERR_MPP;
    }

    sparams->channel_id = stSrcChn.s32ChnId;

    return ERR_NONE;
}

int hisi_encoder_create (unsigned int id,
                        struct encoder_static_params * sparams,
                        struct encoder_dynamic_params * dparams) {
    int error_code = 0;

    if (id < 0 &&
        id >= VENC_MAX_CHN_NUM) return ERR_OBJECT_NOT_FOUNT;

    VENC_CHN_ATTR_S stVencChnAttr;

    error_code = HI_MPI_VENC_GetChnAttr(id, &stVencChnAttr); //TODO Check logic, maybe incorrect
    if (error_code == HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_create: seems encoder slot %d is busy\n", id);
        return ERR_NOT_ALLOWED;
    } else {
        if (error_code != HI_ERR_VENC_UNEXIST) {
            return ERR_MPP;
        }
        printf("C DEBUG: hisi_encoder_create: HI_ERR_VENC_UNEXIST\n going to create encoder\n");
    }

    memset(&stVencChnAttr, 0, sizeof(stVencChnAttr));

    //NOTE There is no garantee that VPSS channel is enabled
    VPSS_CHN_ATTR_S stVpssChnAttr;

    error_code = HI_MPI_VPSS_GetChnAttr(0, sparams->channel_id, &stVpssChnAttr);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_create: HI_MPI_VPSS_GetChnAttr %d failed %#x\n", id, error_code);
        return ERR_MPP;
    }
    int src_fps = stVpssChnAttr.s32DstFrameRate;

    //TODO Check input params
    //...

    //TODO FILL MPP structre

    error_code = HI_MPI_VENC_CreateChn(id, &stVencChnAttr);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: HI_MPI_VENC_CreateChn [%d] faild with %#x!\n", 0, error_code);
        return ERR_MPP;
    }

    error_code = HI_MPI_VENC_StartRecvPic(0);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: HI_MPI_VENC_StartRecvPic faild with%#x!\n", error_code);
        return ERR_MPP;
    }

    MPP_CHN_S stSrcChn;
    MPP_CHN_S stDestChn;

    stSrcChn.enModId = HI_ID_VPSS;
    stSrcChn.s32DevId = 0;
    stSrcChn.s32ChnId = sparams->channel_id;

    stDestChn.enModId = HI_ID_VENC;
    stDestChn.s32DevId = 0;
    stDestChn.s32ChnId = id;

    error_code = HI_MPI_SYS_Bind(&stSrcChn, &stDestChn);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: HI_MPI_SYS_Bind failed with %#x!\n", error_code);
        return ERR_MPP;
    }

    //int fd =  HI_MPI_VENC_GetFd(0);
    //add fd to data getting loop TODO

    return ERR_NONE;
}

int hisi_encoder_update (unsigned int id,
                        struct encoder_dynamic_params * dparams) {
    int error_code = 0;

    if (id < 0 &&
        id >= VENC_MAX_CHN_NUM) return ERR_OBJECT_NOT_FOUNT;

    VENC_CHN_ATTR_S stChnAttr;

    error_code = HI_MPI_VENC_GetChnAttr(id, &stChnAttr);
    if (error_code != HI_SUCCESS) {
        if (error_code == HI_ERR_VENC_UNEXIST) {
            return ERR_OBJECT_NOT_FOUNT;
        }
        return ERR_MPP;
    }

    struct encoder_static_params sparams;
    struct encoder_dynamic_params dparams_cuurent;

    //get s and d params

    //TODO update venc channel, fill new data

    error_code = HI_MPI_VENC_SetChnAttr(id, &stChnAttr);
    if (error_code != HI_SUCCESS) {
        return ERR_MPP;
    }

    return ERR_NONE;
}

int hisi_encoder_delete (unsigned int id) {
    int error_code = 0;

    if (id < 0 &&
        id >= VENC_MAX_CHN_NUM) return ERR_OBJECT_NOT_FOUNT;

    MPP_CHN_S stSrcChn;
    MPP_CHN_S stDestChn;

    stDestChn.enModId  = HI_ID_VENC;
    stDestChn.s32DevId = 0;
    stDestChn.s32ChnId = id;

    error_code =  HI_MPI_SYS_GetBindbyDest(&stDestChn, &stSrcChn);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_delete: HI_MPI_SYS_GetBindbyDest %d failed %#x\n", id, error_code);
        return ERR_MPP;
    }

    error_code = HI_MPI_SYS_UnBind(&stSrcChn, &stDestChn);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_delete: HI_MPI_SYS_UnBind %d failed %#x\n", id, error_code);
        return ERR_MPP;
    }

    error_code = HI_MPI_VENC_StopRecvPic(id);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_delete: HI_MPI_VENC_StopRecvPic %d failed %#x\n", id, error_code);
        return ERR_MPP;
    }

    error_code = HI_MPI_VENC_DestroyChn(id);
    if (error_code != HI_SUCCESS) {
        printf("C DEBUG: hisi_encoder_delete: HI_MPI_VENC_DestroyChn %d failed %#x\n", id, error_code);
        return -1;
    }

    return ERR_NONE;
}

////////////////////////////////////////////////////////////////////////////////

int hi3516av200_set_params(     VENC_CHN_ATTR_S * dst,
                                struct encoder_static_params * sparams,
                                struct encoder_dynamic_params * dparams) {

/*
    switch (sparams->codec) {
        case CODEC_MJPEG:
            stChnAttr.stVeAttr.enType = PT_MJPEG;
            stChnAttr.stVeAttr.stAttrMjpege.u32PicWidth     = sparams->width;
            stChnAttr.stVeAttr.stAttrMjpege.u32PicHeight    = sparams->height;
            stChnAttr.stVeAttr.stAttrMjpege.u32MaxPicWidth  = sparams->width;
            stChnAttr.stVeAttr.stAttrMjpege.u32MaxPicHeight = sparams->height;
            stChnAttr.stVeAttr.stAttrMjpege.u32BufSize      = sparams->width * sparams->height * 3;
            stChnAttr.stVeAttr.stAttrMjpege.bByFrame        = HI_TRUE;
            switch (sparams->rc) {
                case RC_CBR:
                    stChnAttr.stRcAttr.enRcMode                             = VENC_RC_MODE_MJPEGCBR;
                    if (dparams->cbr.stattime != 0) {
                        stChnAttr.stRcAttr.stAttrMjpegeCbr.u32StatTime          = dparams->cbr.stattime;
                    }
                    stChnAttr.stRcAttr.stAttrMjpegeCbr.u32SrcFrmRate        = src_fps;
                    stChnAttr.stRcAttr.stAttrMjpegeCbr.fr32DstFrmRate       = sparams->fps;
                    if (dparams->cbr.fluctuate != 0) {
                        stChnAttr.stRcAttr.stAttrMjpegeCbr.u32FluctuateLevel    = dparams->cbr.fluctuate;
                    }
                    if (dparams->cbr.bitrate != 0) {
                        stChnAttr.stRcAttr.stAttrMjpegeCbr.u32BitRate           = dparams->cbr.bitrate;
                    }
                    break;
                case RC_VBR:
                    stChnAttr.stRcAttr.enRcMode                             = VENC_RC_MODE_MJPEGVBR;
                    stChnAttr.stRcAttr.stAttrMjpegeVbr.u32StatTime          = dparams->vbr.stattime;
                    stChnAttr.stRcAttr.stAttrMjpegeVbr.u32SrcFrmRate        = src_fps;
                    stChnAttr.stRcAttr.stAttrMjpegeVbr.fr32DstFrmRate       = sparams->fps;
                    stChnAttr.stRcAttr.stAttrMjpegeVbr.u32MinQfactor        = dparams->vbr.minqp;
                    stChnAttr.stRcAttr.stAttrMjpegeVbr.u32MaxQfactor        = dparams->vbr.maxqp;
                    break;
                case RC_FIXQP:
                    stChnAttr.stRcAttr.enRcMode                             = VENC_RC_MODE_MJPEGFIXQP;
                    stChnAttr.stRcAttr.stAttrMjpegeFixQp.u32Qfactor         = dparams->fixqp.iqp;
                    stChnAttr.stRcAttr.stAttrMjpegeFixQp.u32SrcFrmRate      = src_fps;
                    stChnAttr.stRcAttr.stAttrMjpegeFixQp.fr32DstFrmRate     = sparams->fps;
                    break;
                default:
                    return ERR_GENERAL;
            }
            break;
        case CODEC_H264:
            stChnAttr.stVeAttr.enType = PT_H264;
            stChnAttr.stVeAttr.stAttrH264e.u32MaxPicWidth       = sparams->width;
            stChnAttr.stVeAttr.stAttrH264e.u32MaxPicHeight      = sparams->height;
            stChnAttr.stVeAttr.stAttrH264e.u32PicWidth          = sparams->width;
            stChnAttr.stVeAttr.stAttrH264e.u32PicHeight         = sparams->height;
            stChnAttr.stVeAttr.stAttrH264e.u32BufSize           = sparams->width * sparams->height * 2;
            switch(sparams->profile) {
                case PROFILE_H264_BASELINE:
                    stChnAttr.stVeAttr.stAttrH264e.u32Profile   = 0;
                    break;
                case PROFILE_H264_MAIN:
                    stChnAttr.stVeAttr.stAttrH264e.u32Profile   = 1;
                    break;
                case PROFILE_H264_HIGH:
                    stChnAttr.stVeAttr.stAttrH264e.u32Profile   = 2;
                    break;
                default:
                    return ERR_GENERAL;
            }
            stChnAttr.stVeAttr.stAttrH264e.bByFrame             = HI_TRUE;
            //stChnAttr.stVeAttr.stAttrH264e.u32BFrameNum       = 0;// 0: not support B frame; >=1: number of B frames
            //stChnAttr.stVeAttr.stAttrH264e.u32RefNum          = 1;// 0: default; number of refrence frame
            switch (sparams->rc) {
                case RC_CBR:
                    stChnAttr.stRcAttr.enRcMode                         = VENC_RC_MODE_H264CBR;
                    stChnAttr.stRcAttr.stAttrH264Cbr.u32Gop             = dparams->cbr.gop;
                    stChnAttr.stRcAttr.stAttrH264Cbr.u32StatTime        = dparams->cbr.stattime;
                    stChnAttr.stRcAttr.stAttrH264Cbr.u32SrcFrmRate      = src_fps;
                    stChnAttr.stRcAttr.stAttrH264Cbr.fr32DstFrmRate     = sparams->fps;
                    stChnAttr.stRcAttr.stAttrH264Cbr.u32FluctuateLevel  = dparams->cbr.fluctuate;
                    stChnAttr.stRcAttr.stAttrH264Cbr.u32BitRate         = dparams->cbr.bitrate;
                    break;
                case RC_VBR:
                    stChnAttr.stRcAttr.enRcMode                         = VENC_RC_MODE_H264VBR;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32Gop             = dparams->vbr.gop;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32StatTime        = dparams->vbr.stattime;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32SrcFrmRate      = src_fps;
                    stChnAttr.stRcAttr.stAttrH264Vbr.fr32DstFrmRate     = sparams->fps;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32MinQp           = dparams->vbr.minqp;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32MinIQp          = dparams->vbr.minqp;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32MaxQp           = dparams->vbr.maxqp;
                    stChnAttr.stRcAttr.stAttrH264Vbr.u32MaxBitRate      = dparams->vbr.maxbitrate;
                    break;
                case RC_FIXQP:
                    stChnAttr.stRcAttr.enRcMode                         = VENC_RC_MODE_H264FIXQP;
                    stChnAttr.stRcAttr.stAttrH264FixQp.u32Gop           = dparams->fixqp.gop;
                    stChnAttr.stRcAttr.stAttrH264FixQp.u32SrcFrmRate    = src_fps;
                    stChnAttr.stRcAttr.stAttrH264FixQp.fr32DstFrmRate   = sparams->fps;
                    stChnAttr.stRcAttr.stAttrH264FixQp.u32IQp           = dparams->fixqp.iqp;
                    stChnAttr.stRcAttr.stAttrH264FixQp.u32PQp           = dparams->fixqp.pqp;
                    stChnAttr.stRcAttr.stAttrH264FixQp.u32BQp           = dparams->fixqp.pqp;
                    break;
                default:
                    return ERR_GENERAL;
            }
            break;
        case CODEC_H265:
            stChnAttr.stVeAttr.enType                       = PT_H265;
            stChnAttr.stVeAttr.stAttrH265e.u32MaxPicWidth   = sparams->width;
            stChnAttr.stVeAttr.stAttrH265e.u32MaxPicHeight  = sparams->height;
            stChnAttr.stVeAttr.stAttrH265e.u32PicWidth      = sparams->width;
            stChnAttr.stVeAttr.stAttrH265e.u32PicHeight     = sparams->height;
            stChnAttr.stVeAttr.stAttrH265e.u32BufSize       = sparams->width * sparams->height * 2;
            stChnAttr.stVeAttr.stAttrH265e.u32Profile       = 0;//only one availible, so...
            stChnAttr.stVeAttr.stAttrH265e.bByFrame         = HI_TRUE;
            //stChnAttr.stVeAttr.stAttrH265e.u32BFrameNum   = 0;// 0: not support B frame; >=1: number of B frames
            //stChnAttr.stVeAttr.stAttrH265e.u32RefNum      = 1;// 0: default; number of refrence frame
            switch (sparams->rc) {
        case CODEC_H265:
            stChnAttr.stVeAttr.enType                       = PT_H265;
            stChnAttr.stVeAttr.stAttrH265e.u32MaxPicWidth   = sparams->width;
            stChnAttr.stVeAttr.stAttrH265e.u32MaxPicHeight  = sparams->height;
            stChnAttr.stVeAttr.stAttrH265e.u32PicWidth      = sparams->width;
            stChnAttr.stVeAttr.stAttrH265e.u32PicHeight     = sparams->height;
            stChnAttr.stVeAttr.stAttrH265e.u32BufSize       = sparams->width * sparams->height * 2;
            stChnAttr.stVeAttr.stAttrH265e.u32Profile       = 0;//only one availible, so...
            stChnAttr.stVeAttr.stAttrH265e.bByFrame         = HI_TRUE;
            //stChnAttr.stVeAttr.stAttrH265e.u32BFrameNum   = 0;// 0: not support B frame; >=1: number of B frames
            //stChnAttr.stVeAttr.stAttrH265e.u32RefNum      = 1;// 0: default; number of refrence frame
            switch (sparams->rc) {
                case RC_CBR:
                    stChnAttr.stRcAttr.enRcMode                         = VENC_RC_MODE_H265CBR;
                    stChnAttr.stRcAttr.stAttrH265Cbr.u32Gop             = dparams->cbr.gop;
                    stChnAttr.stRcAttr.stAttrH265Cbr.u32StatTime        = dparams->cbr.stattime;
                    stChnAttr.stRcAttr.stAttrH265Cbr.u32SrcFrmRate      = src_fps;
                    stChnAttr.stRcAttr.stAttrH265Cbr.fr32DstFrmRate     = sparams->fps;
                    stChnAttr.stRcAttr.stAttrH265Cbr.u32BitRate         = dparams->cbr.bitrate;
                    stChnAttr.stRcAttr.stAttrH265Cbr.u32FluctuateLevel  = dparams->cbr.fluctuate;
                    break;
                case RC_VBR:
                    stChnAttr.stRcAttr.enRcMode                         = VENC_RC_MODE_H265VBR;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32Gop             = dparams->vbr.gop;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32StatTime        = dparams->vbr.stattime;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32SrcFrmRate      = src_fps;
                    stChnAttr.stRcAttr.stAttrH265Vbr.fr32DstFrmRate     = sparams->fps;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32MinQp           = dparams->vbr.minqp;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32MinIQp          = dparams->vbr.minqp;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32MaxQp           = dparams->vbr.maxqp;
                    stChnAttr.stRcAttr.stAttrH265Vbr.u32MaxBitRate      = dparams->vbr.maxbitrate;
                    break;
                case RC_FIXQP:
                    stChnAttr.stRcAttr.enRcMode                         = VENC_RC_MODE_H265FIXQP;
                    stChnAttr.stRcAttr.stAttrH265FixQp.u32Gop           = dparams->fixqp.gop;
                    stChnAttr.stRcAttr.stAttrH265FixQp.u32SrcFrmRate    = src_fps;
                    stChnAttr.stRcAttr.stAttrH265FixQp.fr32DstFrmRate   = sparams->fps;
                    stChnAttr.stRcAttr.stAttrH265FixQp.u32IQp           = dparams->fixqp.iqp;
                    stChnAttr.stRcAttr.stAttrH265FixQp.u32PQp           = dparams->fixqp.pqp;
                    stChnAttr.stRcAttr.stAttrH265FixQp.u32BQp           = dparams->fixqp.pqp;
                    break;
                default:
                    return ERR_GENERAL;
            }
            break;
        default:
            return ERR_GENERAL;
    }

    stChnAttr.stGopAttr.enGopMode               = VENC_GOPMODE_NORMALP;
    stChnAttr.stGopAttr.stNormalP.s32IPQpDelta  = 0;


*/
}

//int hi3516av200_set_dparams(    VENC_CHN_ATTR_S * dst,
//                                struct encoder_dynamic_params * dparams) {
//}

////////////////////////////////////////////////////////////////////////////////

int hi3516av200_get_params(     VENC_CHN_ATTR_S * src,
                                struct encoder_static_params * sparams,
                                struct encoder_dynamic_params * dparams) {
/*
    switch(stChnAttr.stVeAttr.enType) {
        case PT_MJPEG:
            sparams->codec = CODEC_MJPEG;
            switch(stChnAttr.stRcAttr.enRcMode) {
                case VENC_RC_MODE_MJPEGCBR:
                    sparams->rc             = RC_CBR;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrMjpegeCbr.fr32DstFrmRate;

                    dparams->cbr.bitrate    = stChnAttr.stRcAttr.stAttrMjpegeCbr.u32BitRate;
                    dparams->cbr.gop        = PARAM_NO_VALUE;
                    dparams->cbr.stattime   = stChnAttr.stRcAttr.stAttrMjpegeCbr.u32StatTime;
                    dparams->cbr.fluctuate  = stChnAttr.stRcAttr.stAttrMjpegeCbr.u32FluctuateLevel;

                    break;
                case VENC_RC_MODE_MJPEGVBR:
                    sparams->rc             = RC_VBR;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrMjpegeVbr.fr32DstFrmRate;

                    dparams->vbr.maxbitrate = stChnAttr.stRcAttr.stAttrMjpegeVbr.u32MaxBitRate;
                    dparams->vbr.gop        = PARAM_NO_VALUE;
                    dparams->vbr.maxqp      = stChnAttr.stRcAttr.stAttrMjpegeVbr.u32MaxQfactor;
                    dparams->vbr.minqp      = stChnAttr.stRcAttr.stAttrMjpegeVbr.u32MinQfactor;
                    dparams->vbr.stattime   = stChnAttr.stRcAttr.stAttrMjpegeVbr.u32StatTime;

                    break;
                case VENC_RC_MODE_MJPEGFIXQP:
                    sparams->rc             = RC_FIXQP;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrMjpegeFixQp.fr32DstFrmRate;

                    dparams->fixqp.gop      = PARAM_NO_VALUE;
                    dparams->fixqp.iqp      = stChnAttr.stRcAttr.stAttrMjpegeFixQp.u32Qfactor;
                    dparams->fixqp.pqp      = PARAM_NO_VALUE;
                    //dparams->fixqp.stattime = PARAM_NO_VALUE;

                    break;
                default:
                    return ERR_INTERNAL;
            }
            sparams->width      = stChnAttr.stVeAttr.stAttrMjpege.u32PicWidth;
            sparams->height     = stChnAttr.stVeAttr.stAttrMjpege.u32PicHeight;
            sparams->profile    = PROFILE_MJPEG_BASELINE;
            break;
        case PT_H264:
            sparams->codec = CODEC_H264;
            switch(stChnAttr.stRcAttr.enRcMode) {
                case VENC_RC_MODE_H264CBR:
                    sparams->rc             = RC_CBR;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrH264Cbr.fr32DstFrmRate;

                    dparams->cbr.bitrate    = stChnAttr.stRcAttr.stAttrH264Cbr.u32BitRate;
                    dparams->cbr.gop        = stChnAttr.stRcAttr.stAttrH264Cbr.u32Gop;
                    dparams->cbr.stattime   = stChnAttr.stRcAttr.stAttrH264Cbr.u32StatTime;
                    dparams->cbr.fluctuate  = stChnAttr.stRcAttr.stAttrH264Cbr.u32FluctuateLevel;

                    break;
                case VENC_RC_MODE_H264VBR:
                    sparams->rc             = RC_VBR;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrH264Vbr.fr32DstFrmRate;

                    dparams->vbr.maxbitrate = stChnAttr.stRcAttr.stAttrH264Vbr.u32MaxBitRate;
                    dparams->vbr.gop        = stChnAttr.stRcAttr.stAttrH264Vbr.u32Gop;
                    dparams->vbr.maxqp      = stChnAttr.stRcAttr.stAttrH264Vbr.u32MaxQp;
                    dparams->vbr.minqp      = stChnAttr.stRcAttr.stAttrH264Vbr.u32MinQp;
                    dparams->vbr.stattime   = stChnAttr.stRcAttr.stAttrH264Vbr.u32StatTime;

                    break;
                case VENC_RC_MODE_H264FIXQP:
                    sparams->rc             = RC_FIXQP;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrH264FixQp.fr32DstFrmRate;

                    dparams->fixqp.gop      = stChnAttr.stRcAttr.stAttrH264FixQp.u32Gop;
                    dparams->fixqp.iqp      = stChnAttr.stRcAttr.stAttrH264FixQp.u32IQp;
                    dparams->fixqp.pqp      = stChnAttr.stRcAttr.stAttrH264FixQp.u32PQp;
                    //dparams->fixqp.stattime = PARAM_NO_VALUE;

                    break;
                case VENC_RC_MODE_H264AVBR:
                case VENC_RC_MODE_H264QVBR:
                case VENC_RC_MODE_H264QPMAP:
                default:
                    return ERR_INTERNAL;
            }
            sparams->width  = stChnAttr.stVeAttr.stAttrH264e.u32PicWidth;
            sparams->height = stChnAttr.stVeAttr.stAttrH264e.u32PicHeight;
            switch(stChnAttr.stVeAttr.stAttrH265e.u32Profile) { // 0: baseline; 1:MP; 2:HP;  3:svc_t 
                case 0:
                    sparams->profile = PROFILE_H264_BASELINE;
                    break;
                case 1:
                    sparams->profile = PROFILE_H264_MAIN;
                    break;
                case 2:
                    sparams->profile = PROFILE_H264_HIGH;
                    break;
                case 3:
                default:
                    return ERR_INTERNAL;
            }
            break;
        case PT_H265:
            sparams->codec = CODEC_H265;
            switch(stChnAttr.stRcAttr.enRcMode) {
                case VENC_RC_MODE_H265CBR:
                    sparams->rc             = RC_CBR;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrH265Cbr.fr32DstFrmRate;

                    dparams->cbr.bitrate    = stChnAttr.stRcAttr.stAttrH265Cbr.u32BitRate;
                    dparams->cbr.gop        = stChnAttr.stRcAttr.stAttrH265Cbr.u32Gop;
                    dparams->cbr.stattime   = stChnAttr.stRcAttr.stAttrH265Cbr.u32StatTime;
                    dparams->cbr.fluctuate  = stChnAttr.stRcAttr.stAttrH265Cbr.u32FluctuateLevel;

                    break;
                case VENC_RC_MODE_H265VBR:
                    sparams->rc             = RC_VBR;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrH265Vbr.fr32DstFrmRate;

                    dparams->vbr.maxbitrate = stChnAttr.stRcAttr.stAttrH265Vbr.u32MaxBitRate;
                    dparams->vbr.gop        = stChnAttr.stRcAttr.stAttrH265Vbr.u32Gop;
                    dparams->vbr.maxqp      = stChnAttr.stRcAttr.stAttrH265Vbr.u32MaxQp;
                    dparams->vbr.minqp      = stChnAttr.stRcAttr.stAttrH265Vbr.u32MinQp;
                    dparams->vbr.stattime   = stChnAttr.stRcAttr.stAttrH265Vbr.u32StatTime;

                    break;
                case VENC_RC_MODE_H265FIXQP:
                    sparams->rc             = RC_FIXQP;
                    sparams->fps            = stChnAttr.stRcAttr.stAttrH265FixQp.fr32DstFrmRate;

                    dparams->fixqp.gop      = stChnAttr.stRcAttr.stAttrH265FixQp.u32Gop;
                    dparams->fixqp.iqp      = stChnAttr.stRcAttr.stAttrH265FixQp.u32IQp;
                    dparams->fixqp.pqp      = stChnAttr.stRcAttr.stAttrH265FixQp.u32PQp;
                    //dparams->fixqp.stattime = PARAM_NO_VALUE;

                    break;
                case VENC_RC_MODE_H265AVBR:
                case VENC_RC_MODE_H265QVBR:
                case VENC_RC_MODE_H265QPMAP:
                default:
                    return ERR_INTERNAL;
            }
            sparams->width  = stChnAttr.stVeAttr.stAttrH265e.u32PicWidth;
            sparams->height = stChnAttr.stVeAttr.stAttrH265e.u32PicHeight;
            switch(stChnAttr.stVeAttr.stAttrH265e.u32Profile) { //  0:Main
                case 0:
                    sparams->profile = PROFILE_H265_MAIN;
                    break;
                default:
                    return ERR_INTERNAL;
            }
            break;
        default:
            return ERR_INTERNAL;
    }

*/
}

////////////////////////////////////////////////////////////////////////////////

int hi3516av200_check_sparams(  struct encoder_static_params * sparams) {
    int error_num = 0;

    /*
    Should be checked dynamicly according VPSS channel config
    int width;
    int height;
    int fps;
    int channel_id;
    */

    if (sparams->codec != CODEC_MJPEG ||
        sparams->codec != CODEC_H264 ||
        sparams->codec != CODEC_H265) {
        sparams->codec      = PARAM_BAD_VALUE;
        sparams->profile    = PARAM_DISCARDED;
        error_num++;
    } else {
        switch(sparams->codec) {
            case CODEC_MJPEG:
                if (sparams->profile != PROFILE_MJPEG_BASELINE) {
                    sparams->profile = PARAM_BAD_VALUE;
                    error_num++;
                }
                break;
            case CODEC_H264:
                if (sparams->profile != PROFILE_H264_BASELINE ||
                    sparams->profile != PROFILE_H264_MAIN ||
                    sparams->profile != PROFILE_H264_HIGH) {
                    sparams->profile = PARAM_BAD_VALUE;
                    error_num++;
                }
                break;
            case CODEC_H265:
                if (sparams->profile != PROFILE_H265_MAIN) {
                    sparams->profile = PARAM_BAD_VALUE;
                    error_num++;
                }
                break;
        }
    }

    if (sparams->rc != RC_CBR ||
        sparams->rc != RC_VBR ||
        sparams->rc != RC_FIXQP) {
        sparams->rc = PARAM_BAD_VALUE;
        error_num++;
    }

    return error_num;
}

int hi3516av200_check_dparams(  struct encoder_static_params * sparams,
                                struct encoder_dynamic_params * dparams) {
    int error_num = 0;

    switch (sparams->rc) {
        case RC_CBR:
            if (dparams->cbr.bitrate < 0 ||
                dparams->cbr.bitrate > 1024*10) { //TODO max limit should be adjusted
                    dparams->cbr.bitrate = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->cbr.gop < 0 ||
                dparams->cbr.gop > 100) { //TODO min & max limits should be adjusted
                    dparams->cbr.gop = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->cbr.stattime < 0 ||
                dparams->cbr.stattime > 1) { //TODO min & max limits should be adjusted
                    dparams->cbr.stattime = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->cbr.fluctuate < 0 ||
                dparams->cbr.fluctuate > 5) { //TODO min & max limits should be adjusted
                    dparams->cbr.fluctuate = PARAM_BAD_VALUE;
                    error_num++;
            }
            break;
        case RC_VBR:
            if (dparams->vbr.maxbitrate < 0 ||
                dparams->vbr.maxbitrate > 1024*10) {
                    dparams->vbr.maxbitrate = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->vbr.gop < 0 ||
                dparams->vbr.gop > 60) {
                    dparams->vbr.gop = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->vbr.maxqp < 0 ||
                dparams->vbr.maxqp > 90) {
                    dparams->vbr.maxqp = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->vbr.minqp < 0 ||
                dparams->vbr.minqp > 90) {
                    dparams->vbr.minqp = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->vbr.stattime < 0 ||
                dparams->vbr.stattime > 1) {
                    dparams->vbr.stattime = PARAM_BAD_VALUE;
                    error_num++;
            }
            break;
        case RC_FIXQP:
            if (dparams->fixqp.gop < 0 ||
                dparams->fixqp.gop > 60) {
                    dparams->fixqp.gop = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->fixqp.iqp < 0 ||
                dparams->fixqp.iqp > 90) {
                    dparams->fixqp.iqp = PARAM_BAD_VALUE;
                    error_num++;
            }
            if (dparams->fixqp.pqp < 0 ||
                dparams->fixqp.pqp > 90) {
                    dparams->fixqp.pqp = PARAM_BAD_VALUE;
                    error_num++;
            }
            break;
        case RC_AVBR:
        case RC_QVBR:
        case RC_QMAP:
        default:
            return ERR_INTERNAL;
            break;
    }

    return error_num;
}



